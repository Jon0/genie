#include "Buffer.h"

#include <assert.h>
#include <string.h>

Buffer::Buffer(int size)
{
	rawData = new char[size];
	rawBufferPos = 0;
	rawBufferSize = size;
}

Buffer::~Buffer()
{
	delete[] rawData;
}


// A bit like strstr, but for not-NULL-terminated data
int memmem_naive(const char* data, int data_len, const char* search, int search_len)
{
	bool matched;
	for (int s = 0; s <= data_len - search_len; ++s)
	{
		matched = true;
		for (int i = 0; i < search_len; ++i)
			if (data[s+i] != search[i])
			{
				matched = false;
				break;
			}
		if (matched)
			return s;
	}
	return -1;
}

// Well, at least it's the same general concept as Rabin-Karp...
// (and it's ever so very slightly faster than the 'naive' method,
// for the uses which I use it for. And an awful lot faster/simpler
// than real Rabin-Karp for those uses.)
int memmem_mutant_rabin_karp(const char* data, int data_len, const char* search, int search_len)
{
	bool matched;

	char p = 0; // provides automatic modulo 256 (sort of)
	char t = 0;

	int max = data_len-search_len;

	for (int j = 0; j < search_len; ++j)
	{
		p += search[j];
		t += data[j];
	}
	for (int s = 0; s <= max; ++s)
	{
		if (p == t)
		{
			matched = true;
			for (int i = 0; i < search_len; ++i)
				if (data[s+i] != search[i])
				{
					matched = false;
					break;
				}
			if (matched)
				return s;
		}
		t = t - data[s] + data[s+search_len]; // very very cheap hash
	}

	return -1;
}


int Buffer::find(const char* str)
{
//	return memmem_naive(rawData, rawBufferSize, str, strlen(str));
	return memmem_mutant_rabin_karp(rawData, rawBufferSize, str, strlen(str));
}

/*
void Buffer::read(void* item, const int size)
{
	int read_size = size;
	// Avoid falling off the end
	if (rawBufferPos+size >= rawBufferSize)
	{
		assert(! "Fell of the end!");
		read_size = rawBufferSize-rawBufferPos;
	}

	memcpy(item, &rawData[rawBufferPos], read_size);
	rawBufferPos += read_size;
}

void Buffer::write(void* item, const int size)
{
	int write_size = size;
	// Avoid falling off the end
	if (rawBufferPos+size >= rawBufferSize)
	{
		assert(! "Fell of the end!");
		write_size = rawBufferSize-rawBufferPos;
	}

	memcpy(&rawData[rawBufferPos], item, write_size);
	rawBufferPos += write_size;
}

void Buffer::seek(const int pos)
{
	rawBufferPos = pos;
}

void Buffer::jump(const int pos)
{
	rawBufferPos = pos;
}

int Buffer::tell()
{
	return rawBufferPos;
}
*/
